name: U (Universal Turing Machine)
source code: |
  # The Universal Turing Machine (U) can simulate any other Turing machine. This intuitively supports
  # the Church-Turing thesis, which states that any computation can be performed by a Turing machine. Also
  # understanding the idea of U helps understand the stored program concept, which is the basis of modern computers
  # including interpreters and compilers.
  #
  # The specific coding for the input works by first encoding the transitons, then the simulated input.
  # Specifically: 
  #      Input state (three 1s for the initial state, four 1s for the next state, etc.) followed by a 0.
  #      Input symbol (single 1 for blank, two 1s for the first non-blank symbol, etc.) followed by a 0.
  #      Next state (one 1 or two 1s for halting states, h_a and h_r) followed by a 0.
  #      Write sybol followed by a 0.
  #      Move direction (one 1 for left, two 1s for right, three 1s for stay) followed by a 0.
  #  A second 0 in a row will separate transitions
  #  A third 0 in a row will separate the transitions from the input.
  # Using these rules, the "binary increment" machine with initial input '1011' could be encoded as
  # "11101011110101100111011011101101001110111011101110100111101010111011001111011010111011001111011101111011011000111011011101110".
  # Note that the exact translation from "state name" to 1111s could legaly vary as long as the states are consistent 
  # within a given encoding.

  type: 3tape
  input: '11101011110101100111011011101101001110111011101110100111101010111011001111011010111011001111011101111011011000111011011101110'
  blank: ' '
  wild: '.'
  start state: WriteStartState
  
  # How it works:
  # Tape 3 will contain the simulated state, initialized to 1110.
  # Tape 2 will contain the simulated tape, copied from the input portion of tape 1's input.
  # Tape 1 will contain the transition table.

  # The machine will:
  # Scan tape 1 to match the current state (on tape 3) and the current symbol (on tape 2).
  # No match = halt. (with some changes, we could copy the simulated tape to tape 1)
  # If a match is found, it will:
  # 1. Replace the state on tape 3 with the next state.
  # 2. Replace the symbol on tape 2 with the write symbol. Note that this may mean shifting the existing tape contents left or right.
  # 3. Move the tape head on tape 2 in the specified direction. This will mean shifting to the next 0 rather than a single step, and may mean creating a new blank (10).
  # 4. Rewind tape 1 and repeat.

  table:
  # Initialize, part1: Write the initial state to tape 3
    WriteStartState:
      '...': {write: '..1', move: SSR, next: WSS1}
    WSS1:
      '...': {write: '..1', move: SSR, next: WSS2}
    WSS2:
      '...': {write: '..1', move: SSR, next: WSS3}
    WSS3:
      '...': {write: '..0', move: SSL, next: SkipToInput}

    
  # Initialize, part2: Copy the input tape to tape 2. 3 0s in a row mark the start of input
  # A blank prior to 3 0s indicate no input (blank tape). 
  # Note that the input might or might not end with a 0 -- if not we add one after copying.
    SkipToInput:
      '1..': {move: RSS}
      '0..': {move: RSS, next: SkipToInput1}
      ' ..': {next: BlankInput}
    SkipToInput1:
      '1..': {move: RSS, next: SkipToInput}
      '0..': {move: RSS, next: SkipToInput2}
      ' ..': {next: BlankInput}
    SkipToInput2:
      '1..': {move: RSS, next: SkipToInput}
      '0..': {move: RSS, next: CopyInputStart}
      ' ..': {next: BlankInput}

    BlankInput:
      '...': {write: '.1.', move: SRS, next: BlankInput1}
    BlankInput1:
      '...': {write: '.0.', move: LLS, next: RewindTransitions}

    CopyInputStart:
      '1..': {write: ' 1.', move: RRS, next: CopyInput1}
      '0..': {write: ' 0.', move: RRS, next: CopyInput0}
      ' ..': {next: BlankInput}

    CopyInput1:
      '1..': {write: ' 1.', move: RRS}
      '0..': {write: ' 0.', move: RRS, next: CopyInput0}
      ' ..': {write: ' 0.', move: LSS, next: RewindInput}

    CopyInput0:
      '1..': {write: ' 1.', move: RRS, next: CopyInput1}
      '0..': {write: ' 0.', move: RRS}   # Two zeros in a row??
      ' ..': {move: LLS, next: RewindInput}

    RewindInput:
      '.1.': {move: LLS}
      '.0.': {move: LLS}
      '. .': {move: SRS, next: RewindTransitions}

    # Setup for next transition: Rewind the transition table on tape 1 and state on tape 3
    RewindTransitions:
      '1..': {move: LSS}
      '0..': {move: LSS}
      ' ..': {move: RSS, next: RewindState}
      
    RewindState:
      '..1': {move: SSL}
      '.. ': {move: SSR, next: MatchState}

    MatchState:
      # Match the current state on tape 3 with the transition table on tape 1
      # If no match, halt.
      '1.1': {move: RSR}
      '0.0': {move: RSL, next: MatchSymbol}
      '1.0': {move: SSL, next: SkipTransition}
      '0.1': {move: SSS, next: SkipTransition}
      ' ..': {move: LSR, next: finish}

    MatchSymbol:
      # Match the current symbol on tape 2 with the transition table on tape 1
      '11.': {move: RRS}
      '00.': {move: RLS, next: ChangeStateRewind}
      '10.': {move: SLS, next: RewindSymbolForNextTransition}
      '01.': {move: LSS, next: RewindSymbolForNextTransition}

    RewindSymbolForNextTransition:
      # Rewind the symbol on tape 2
      '.1.': {move: SLS}
      '. .': {move: SRS, next: SkipTransition}
      '.0.': {move: SRS, next: SkipTransition}

    SkipTransition:
      # Skip to the next transition in tape 1 (00)
      '1..': {move: RSS}
      '0..': {move: RSS, next: SkipTransition1}
      ' ..': {move: LSR, next: finish}
    SkipTransition1:  
      '1..': {move: RSS, next: SkipTransition}
      '0..': {move: RSS, next: RewindState}
      ' ..': {move: LSR, next: finish}

    ChangeStateRewind:
      # Match found! Rewind state, then copy the next state to tape 3.
      '..1': {move: SSL}
      '.. ': {move: SSR, next: WriteNextState}
    WriteNextState:
      '1..': {write: '..1', move: RSR}
      '0..': {write: '..0', move: RSL, next: WriteSymbolRewind}

    WriteSymbolRewind:
      # Rewind symbol on tape 2, then copy from tape 1
      '.1.': {move: SLS}
      '.0.': {move: SRS, next: WriteSymbol}
      '. .': {move: SRS, next: WriteSymbol}
    WriteSymbol:
      '11.': {move: RRS}
      '00.': {move: RSS, next: MoveHead}
      '10.': {write: '. .', move: SRS, next: RightShift0}
      '01.': {write: '. .', move: SRS, next: LeftShiftFastForward}

    RightShift0:
      '.1.': {write: '.0.', move: SRS, next: RightShift1}
      '.0.': {write: '.0.', move: SRS, next: RightShift0}
      '. .': {write: '.0.', move: SLS, next: RiftShiftRewind}
    RightShift1:
      '.1.': {write: '.1.', move: SRS, next: RightShift1}
      '.0.': {write: '.1.', move: SRS, next: RightShift0}
      '. .': {write: '.1.', move: SLS, next: RiftShiftRewind}
    RiftShiftRewind:
      # Rewind the tape after shifting right
      '.1.': {move: SLS}
      '.0.': {move: SLS}
      '. .': {write: '.1.', move: SSS, next: WriteSymbol}

    LeftShiftFastForward:
      # Move to rght end of tape 2, then shift left
      '.1.': {move: SRS}
      '.0.': {move: SRS}
      '. .': {move: SLS, next: LeftShiftSpace}
    LeftShiftSpace:
      '.1.': {write: '. .', move: SLS, next: LeftShift1}
      '.0.': {write: '. .', move: SLS, next: LeftShift0}
    LeftShift0:
      '.1.': {write: '.0.', move: SLS, next: LeftShift1}
      '.0.': {write: '.0.', move: SLS, next: LeftShift0}
      '. .': {write: '.0.', move: SSS, next: WriteSymbol}
    LeftShift1:
      '.1.': {write: '.1.', move: SLS, next: LeftShift1}
      '.0.': {write: '.1.', move: SLS, next: LeftShift0}
      '. .': {write: '.1.', move: SSS, next: WriteSymbol}

    MoveHead:
      # Move the tape head on tape 2 in the specified direction.
      # At this point, the head is on the 0 between the current symbol (S) and the next symbol (R).
      '10.': {move: RSS, next: MoveHead1}

    MoveHead1:
      '10.': {move: RSS, next: MoveHead2}       # not R
      '00.': {move: RRS, next: CheckBlankRight} # R - add blank if needed

    MoveHead2:
      '10.': {move: SLS, next: LeftOneSymbol}  # S
      '00.': {move: LLS, next: LeftTwoSymbol}  # L 

    LeftTwoSymbol:
      '.1.': {move: SLS}
      '.0.': {move: SLS, next: LeftOneSymbol}
      '. .': {write: '.0.', move: SLS, next: LeftAddBlank}
    LeftOneSymbol:
      '.1.': {move: SLS}
      '.0.': {move: SRS, next: RewindTransitions} 
      '. .': {move: SRS, next: RewindTransitions}
    LeftAddBlank:
      '. .': {write: '.1.', move: SSS, next: RewindTransitions}

    CheckBlankRight:
      # If the next symbol is blank, we need to add a blank.
      '. .': {write: '.1.', move: SRS, next: AddBlankRight}
      '.1.': {move: SSS, next: RewindTransitions}

    AddBlankRight:
      '. .': {write: '.0.', move: SLS, next: RewindTransitions}
      
    finish:
      # If we reach here, we have no match, so we halt.
      # We could copy the simulated tape to tape 1 if needed.
      '..0': {move: SSS, next: accept}
      '..1': {move: SSS, next: reject}

    accept:
    reject:

positions:
# Centralized, Radial Layout
  # Center hub
  MatchState: {x: 365.83, y: 762.99}
  MatchSymbol: {x: 208.17, y: 757.73}
  WriteSymbol: {x: 466.91, y: 169.53}
  finish: {x: 382.42, y: 461.56}
  accept: {x: 775.03, y: 454.56}
  reject: {x: 594.84, y: 559.28}

  # Initialization arc (upper left)
  WriteStartState: {x: 137.96, y: 74.94}
  WSS1:           {x: 328.90, y: 43.06}
  WSS2:           {x: 489.01, y: 38.55}
  WSS3:           {x: 642.94, y: 44.53}
  SkipToInput:    {x: 797.29, y: 76.61}
  SkipToInput1:   {x: 961.65, y: 90.63}
  SkipToInput2:   {x: 1126.88, y: 115.91}

  # Input Copying arc (upper right)
  CopyInputStart: {x: 1094.90, y: 466.90}
  CopyInput1:     {x: 1074.22, y: 617.30}
  CopyInput0:     {x: 1118.84, y: 766.81}
  RewindInput:    {x: 865.65, y: 761.32}
  BlankInput:     {x: 1150.64, y: 210.04}
  BlankInput1:    {x: 1150.71, y: 365.99}

  # Main Loop & Matching (left and right spokes)
  RewindTransitions: {x: 723.16, y: 766.60}
  RewindState: {x: 519.02, y: 764.19}
  RewindSymbolForNextTransition: {x: 272.83, y: 587.89}
  SkipTransition: {x: 122.19, y: 670.96}
  SkipTransition1: {x: 63.35, y: 522.77}

  # State & Symbol Writing (lower right arc)
  ChangeStateRewind:   {x: 83.48, y: 404.87}
  WriteNextState:      {x: 73.42, y: 268.23}
  WriteSymbolRewind:   {x: 255.20, y: 169.15}

  # Tape Head Movement (bottom right, vertical)
  MoveHead:        {x: 436.98, y: 581.38}
  MoveHead1:       {x: 253.14, y: 448.46}
  MoveHead2:       {x: 201.95, y: 337.64}
  LeftOneSymbol:   {x: 534.65, y: 290.44}
  LeftTwoSymbol:   {x: 313.58, y: 244.78}
  LeftAddBlank:    {x: 724.24, y: 369.28}
  CheckBlankRight: {x: 916.85, y: 289.88}
  AddBlankRight:   {x: 1045.48, y: 317.60}

  # Tape Shifting (Complex) Group (bottom left, grid)
  RightShift0:        {x: 673.43, y: 178.81}
  RightShift1:        {x: 848.84, y: 216.47}
  RiftShiftRewind:   {x: 1009.30, y: 227.42}
  LeftShiftFastForward: {x: 992.39, y: 413.55}
  LeftShiftSpace:     {x: 895.54, y: 529.18}
  LeftShift0:         {x: 762.61, y: 636.95}
  LeftShift1:         {x: 551.73, y: 664.43}
