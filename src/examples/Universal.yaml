name: U (Universal Turing Machine)
source code: |
  # The Universal Turing Machine (U) can simulate any other Turing machine. This intuitively supports
  # the Church-Turing thesis, which states that any computation can be performed by a Turing machine. Also
  # understanding the idea of U helps understand the stored program concept, which is the basis of modern computers
  # including interpreters and compilers.
  #
  # The specific coding for the input works by first encoding the transitons, then the simulated input.
  # Specifically: 
  #      Input state (three 1s for the initial state, four 1s for the next state, etc.) followed by a 0.
  #      Input symbol (single 1 for blank, two 1s for the first non-blank symbol, etc.) followed by a 0.
  #      Next state (one 1 or two 1s for halting states, h_a and h_r) followed by a 0.
  #      Write sybol followed by a 0.
  #      Move direction (one 1 for left, two 1s for right, three 1s for stay) followed by a 0.
  #  A second 0 in a row will separate transitions
  #  A third 0 in a row will separate the transitions from the input.
  # Using these rules, the "binary increment" machine with initial input '1011' could be encoded as
  # "11101011110101100111011011101101001110111011101110100111101010111011001111011010111011001111011101111011011000111011011101110".
  # Note that the exact translation from "state name" to 1111s could legaly vary as long as the states are consistent 
  # within a given encoding.

  type: 3tape
  input: '11101011110101100111011011101101001110111011101110100111101010111011001111011010111011001111011101111011011000111011011101110'
  blank: ' '
  wild: '.'
  start state: WriteStartState
  
  # How it works:
  # Tape 3 will contain the simulated state, initialized to 1110.
  # Tape 2 will contain the simulated tape, copied from the input portion of tape 1's input.
  # Tape 1 will contain the transition table.

  # The machine will:
  # Scan tape 1 to match the current state (on tape 3) and the current symbol (on tape 2).
  # No match = halt. (with some changes, we could copy the simulated tape to tape 1)
  # If a match is found, it will:
  # 1. Replace the state on tape 3 with the next state.
  # 2. Replace the symbol on tape 2 with the write symbol. Note that this may mean shifting the existing tape contents left or right.
  # 3. Move the tape head on tape 2 in the specified direction. This will mean shifting to the next 0 rather than a single step, and may mean creating a new blank (10).
  # 4. Rewind tape 1 and repeat.

  table:
  # Initialize, part1: Write the initial state to tape 3
    WriteStartState:
      '...': {write: '..1', move: SSR, next: WSS1}
    WSS1:
      '...': {write: '..1', move: SSR, next: WSS2}
    WSS2:
      '...': {write: '..1', move: SSR, next: WSS3}
    WSS3:
      '...': {write: '..0', move: SSL, next: SkipToInput}

    
  # Initialize, part2: Copy the input tape to tape 2. 3 0s in a row mark the start of input
  # A blank prior to 3 0s indicate no input (blank tape). 
  # Note that the input might or might not end with a 0 -- if not we add one after copying.
    SkipToInput:
      '1..': {move: RSS}
      '0..': {move: RSS, next: SkipToInput1}
      ' ..': {next: BlankInput}
    SkipToInput1:
      '1..': {move: RSS, next: SkipToInput}
      '0..': {move: RSS, next: SkipToInput2}
      ' ..': {next: BlankInput}
    SkipToInput2:
      '1..': {move: RSS, next: SkipToInput}
      '0..': {move: RSS, next: CopyInputStart}
      ' ..': {next: BlankInput}

    BlankInput:
      '...': {write: '.1.', move: SRS, next: BlankInput1}
    BlankInput1:
      '...': {write: '.0.', move: LLS, next: RewindTransitions}

    CopyInputStart:
      '1..': {write: ' 1.', move: RRS, next: CopyInput1}
      '0..': {write: ' 0.', move: RRS, next: CopyInput0}
      ' ..': {next: BlankInput}

    CopyInput1:
      '1..': {write: ' 1.', move: RRS}
      '0..': {write: ' 0.', move: RRS, next: CopyInput0}
      ' ..': {write: ' 0.', move: LSS, next: RewindInput}

    CopyInput0:
      '1..': {write: ' 1.', move: RRS, next: CopyInput1}
      '0..': {write: ' 0.', move: RRS}   # Two zeros in a row??
      ' ..': {move: LLS, next: RewindInput}

    RewindInput:
      '.1.': {move: LLS}
      '.0.': {move: LLS}
      '. .': {move: SRS, next: RewindTransitions}

    # Setup for next transition: Rewind the transition table on tape 1 and state on tape 3
    RewindTransitions:
      '1..': {move: LSS}
      '0..': {move: LSS}
      ' ..': {move: RSS, next: RewindState}
      
    RewindState:
      '..1': {move: SSL}
      '.. ': {move: SSR, next: MatchState}

    MatchState:
      # Match the current state on tape 3 with the transition table on tape 1
      # If no match, halt.
      '1.1': {move: RSR}
      '0.0': {move: RSL, next: MatchSymbol}
      '1.0': {move: SSL, next: SkipTransition}
      '0.1': {move: SSS, next: SkipTransition}
      ' ..': {move: LSR, next: finish}

    MatchSymbol:
      # Match the current symbol on tape 2 with the transition table on tape 1
      '11.': {move: RRS}
      '00.': {move: RLS, next: ChangeStateRewind}
      '10.': {move: SLS, next: RewindSymbolForNextTransition}
      '01.': {move: LSS, next: RewindSymbolForNextTransition}

    RewindSymbolForNextTransition:
      # Rewind the symbol on tape 2
      '.1.': {move: SLS}
      '. .': {move: SRS, next: SkipTransition}
      '.0.': {move: SRS, next: SkipTransition}

    SkipTransition:
      # Skip to the next transition in tape 1 (00)
      '1..': {move: RSS}
      '0..': {move: RSS, next: SkipTransition1}
      ' ..': {move: LSR, next: finish}
    SkipTransition1:  
      '1..': {move: RSS, next: SkipTransition}
      '0..': {move: RSS, next: RewindState}
      ' ..': {move: LSR, next: finish}

    ChangeStateRewind:
      # Match found! Rewind state, then copy the next state to tape 3.
      '..1': {move: SSL}
      '.. ': {move: SSR, next: WriteNextState}
    WriteNextState:
      '1..': {write: '..1', move: RSR}
      '0..': {write: '..0', move: RSL, next: WriteSymbolRewind}

    WriteSymbolRewind:
      # Rewind symbol on tape 2, then copy from tape 1
      '.1.': {move: SLS}
      '.0.': {move: SRS, next: WriteSymbol}
      '. .': {move: SRS, next: WriteSymbol}
    WriteSymbol:
      '11.': {move: RRS}
      '00.': {move: RSS, next: MoveHead}
      '10.': {write: '. .', move: SRS, next: RightShift0}
      '01.': {write: '. .', move: SRS, next: LeftShiftFastForward}

    RightShift0:
      '.1.': {write: '.0.', move: SRS, next: RightShift1}
      '.0.': {write: '.0.', move: SRS, next: RightShift0}
      '. .': {write: '.0.', move: SLS, next: RiftShiftRewind}
    RightShift1:
      '.1.': {write: '.1.', move: SRS, next: RightShift1}
      '.0.': {write: '.1.', move: SRS, next: RightShift0}
      '. .': {write: '.1.', move: SLS, next: RiftShiftRewind}
    RiftShiftRewind:
      # Rewind the tape after shifting right
      '.1.': {move: SLS}
      '.0.': {move: SLS}
      '. .': {write: '.1.', move: SSS, next: WriteSymbol}

    LeftShiftFastForward:
      # Move to rght end of tape 2, then shift left
      '.1.': {move: SRS}
      '.0.': {move: SRS}
      '. .': {move: SLS, next: LeftShiftSpace}
    LeftShiftSpace:
      '.1.': {write: '. .', move: SLS, next: LeftShift1}
      '.0.': {write: '. .', move: SLS, next: LeftShift0}
    LeftShift0:
      '.1.': {write: '.0.', move: SLS, next: LeftShift1}
      '.0.': {write: '.0.', move: SLS, next: LeftShift0}
      '. .': {write: '.0.', move: SSS, next: WriteSymbol}
    LeftShift1:
      '.1.': {write: '.1.', move: SLS, next: LeftShift1}
      '.0.': {write: '.1.', move: SLS, next: LeftShift0}
      '. .': {write: '.1.', move: SSS, next: WriteSymbol}

    MoveHead:
      # Move the tape head on tape 2 in the specified direction.
      # At this point, the head is on the 0 between the current symbol (S) and the next symbol (R).
      '10.': {move: RSS, next: MoveHead1}

    MoveHead1:
      '10.': {move: RSS, next: MoveHead2}       # not R
      '00.': {move: RRS, next: CheckBlankRight} # R - add blank if needed

    MoveHead2:
      '10.': {move: SLS, next: LeftOneSymbol}  # S
      '00.': {move: LLS, next: LeftTwoSymbol}  # L 

    LeftTwoSymbol:
      '.1.': {move: SLS}
      '.0.': {move: SLS, next: LeftOneSymbol}
      '. .': {write: '.0.', move: SLS, next: LeftAddBlank}
    LeftOneSymbol:
      '.1.': {move: SLS}
      '.0.': {move: SRS, next: RewindTransitions} 
      '. .': {move: SRS, next: RewindTransitions}
    LeftAddBlank:
      '. .': {write: '.1.', move: SSS, next: RewindTransitions}

    CheckBlankRight:
      # If the next symbol is blank, we need to add a blank.
      '. .': {write: '.1.', move: SRS, next: AddBlankRight}
      '.1.': {move: SSS, next: RewindTransitions}

    AddBlankRight:
      '. .': {write: '.0.', move: SLS, next: RewindTransitions}
      
    finish:
      # If we reach here, we have no match, so we halt.
      # We could copy the simulated tape to tape 1 if needed.
      '..0': {move: SSS, next: accept}
      '..1': {move: SSS, next: reject}

    accept:
    reject:

positions:
# Centralized, Radial Layout
  # Center hub
  MatchState: {x: 51, y: 378}
  MatchSymbol: {x: 51, y: 271}
  WriteSymbol: {x: 800, y: 400}
  finish: {x: 600, y: 520}
  accept: {x: 540, y: 600}
  reject: {x: 660, y: 600}

  # Initialization arc (upper left)
  WriteStartState: {x: 75.13, y: 79.59}
  WSS1:           {x: 177, y: 20}
  WSS2:           {x: 328, y: 20}
  WSS3:           {x: 505, y: 20}
  SkipToInput:    {x: 667, y: 20}
  SkipToInput1:   {x: 780, y: 101}
  SkipToInput2:   {x: 753, y: 20}

  # Input Copying arc (upper right)
  CopyInputStart: {x: 752, y: 407}
  CopyInput1:     {x: 665, y: 468}
  CopyInput0:     {x: 523, y: 480}
  RewindInput:    {x: 388, y: 480}
  BlankInput:     {x: 752, y: 157}
  BlankInput1:    {x: 752, y: 279}

  # Main Loop & Matching (left and right spokes)
  RewindTransitions: {x: 237, y: 480}
  RewindState: {x: 99, y: 480}
  RewindSymbolForNextTransition: {x: 157, y: 139}
  SkipTransition: {x: 339, y: 139}
  SkipTransition1: {x: 465, y: 139}

  # State & Symbol Writing (lower right arc)
  ChangeStateRewind:   {x: 624, y: 139}
  WriteNextState:      {x: 860, y: 540}
  WriteSymbolRewind:   {x: 920, y: 600}

  # Tape Head Movement (bottom right, vertical)
  MoveHead:        {x: 800, y: 600}
  MoveHead1:       {x: 800, y: 680}
  MoveHead2:       {x: 800, y: 760}
  LeftOneSymbol:   {x: 900, y: 700}
  LeftTwoSymbol:   {x: 900, y: 780}
  LeftAddBlank:    {x: 1000, y: 780}
  CheckBlankRight: {x: 900, y: 860}
  AddBlankRight:   {x: 1000, y: 860}

  # Tape Shifting (Complex) Group (bottom left, grid)
  RightShift0:        {x: 400, y: 600}
  RightShift1:        {x: 480, y: 640}
  RiftShiftRewind:    {x: 440, y: 720}
  LeftShiftFastForward: {x: 520, y: 680}
  LeftShiftSpace:     {x: 600, y: 720}
  LeftShift0:         {x: 680, y: 680}
  LeftShift1:         {x: 760, y: 640}
